using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using PathGraph;

namespace libSE2014
{
    public enum Direction { Forward, Left, Right, Backward };

    /// <summary>
    /// The component has an image, a direction and a vertex
    /// This represents a 'step' for the user or a 'direction'
    /// Ex: turn left from where you are and you will see... (image)
    /// </summary>
    public class GraphPathComponent
    {
        private Vertex _v;
        private String _imgPath;
        private Direction _direction;
        private Vertex _destinationVertex;
        private Edge _edge;

        /// <summary>
        /// Constructor, the destination vertex is only valid if this is the last GraphPathComponent since it 'points' to the destination
        /// </summary>
        public GraphPathComponent(Vertex v, String imgPath, Direction direction, Vertex destinationVert, Edge edge)
        {
            _v = v;
            _imgPath = imgPath;
            _destinationVertex = destinationVert;
            _direction = direction;
            _edge = edge;
        }

        public Vertex Vertex
        {
            get
            {
                return _v;
            }
        }

        public String ImagePath
        {
            get
            {
                return _imgPath;
            }
        }


        public Direction Direction
        {
            get
            {
                return _direction;
            }
        }

        public String DirectionString
        {
            get
            {
                switch (_direction)
                {
                    case Direction.Forward:
                        return "Forward";
                    case Direction.Backward:
                        return "Backward";
                    case Direction.Left:
                        return "Left";
                    case Direction.Right:
                        return "Right";
                    default:
                        return "Unknown Direction";
                }
            }
        }

        public Vertex DestinationVertex
        {
            get
            {
                return _destinationVertex;
            }
        }

        public Edge Edge
        {
            get
            {
                return _edge;
            }
        }
    }

    /// <summary>
    /// This takes a list of verticies for the shortest path and uses that to generate a list of GraphPathComponents 
    /// It determines the direction the user must go relative to where they are
    /// It can also optimize out redundant movements forward
    /// </summary>
    public class GraphPathAssembler
    {
        private List<Vertex> _pathVerticies;
        private List<Edge> _allEdges;
        private String _imageRelPath;

        /// <summary>
        /// Given 2 verticies, it finds the corresponding edge
        /// </summary>
        private Edge GetEdge(Vertex v1, Vertex v2)
        {
            foreach (var e in _allEdges)
            {
                if ((e.PointA == v1 && e.PointB == v2) ||
                    (e.PointA == v2 && e.PointB == v1))
                {
                    return e;
                }
            }

            return null;
        }

        /// <summary>
        /// Given connected verticies A B C, if determines the turn the user must take to go
        /// from edge A B to edge B C
        /// This works by taking a 2D cross product and looking at the determinant
        /// </summary>
        private Direction DetermineDirectionOfV2(Vertex v1, Vertex v2, Vertex v3)
        {
            if (v1 == null || v2 == null || v3 == null)
                return Direction.Forward;

            double ax = v2.XCoord - v1.XCoord;
            double ay = v2.YCoord - v1.YCoord;
            double bx = v3.XCoord - v2.XCoord;
            double by = v3.YCoord - v2.YCoord;

            //the determinant of the cross product
            //if you love math check out http://mathworld.wolfram.com/CrossProduct.html
            double z = ax * by - ay * bx;

            if (z > 0.0) return Direction.Left;
            if (z < 0.0) return Direction.Right;
            return Direction.Forward;
        }

        /// <summary>
        /// Takes in the path verticies generated by Graph, the edges of the graph, and the relative image path
        /// that is appended to the image location
        /// </summary>
        public GraphPathAssembler(List<Vertex> pathVerticies, List<Edge> allEdges, String imageRelativePath)
        {
            _pathVerticies = pathVerticies.ConvertAll(vert => vert);
            _allEdges = allEdges.ConvertAll(edge => edge);
            _imageRelPath = imageRelativePath;

        }

        /// <summary>
        /// Generates the path
        /// </summary>
        public List<GraphPathComponent> GeneratePath()
        {
            var path = new List<GraphPathComponent>();

            //need at least 2 verticies
            if(_pathVerticies.Count < 2)
                return path;

            Vertex previous = null;
            Vertex current = null;
            Vertex next = null;

            //look at the previous, current, and next vertex
            //associate the images and other data to generate GraphPathComponents
            for (int i = 0; i < _pathVerticies.Count - 1; i++)
            {
                current = _pathVerticies[i];
                next = _pathVerticies[i + 1];

                var imgPath = "";

                //get the edge from where we are to where we are going
                var edge = GetEdge(current,next);

                //edge not found
                if(edge == null)
                    return new List<GraphPathComponent>();

                //figure out the image path based on where the vertex is on the edge
                if(edge.PointA == current)
                {
                    if(edge.FirstImage.Length > 0)
                    {
                        imgPath = _imageRelPath + edge.FirstImage;
                    }
                }
                else
                {
                    if(edge.SecondImage.Length > 0)
                    {
                        imgPath = _imageRelPath + edge.SecondImage;
                    }
                }

                Vertex destVertex = null;

                //if this is the before last vertex, associate the last vertex 
                if(i == _pathVerticies.Count - 2)
                    destVertex = _pathVerticies[_pathVerticies.Count - 1];

                //generate a new component and add it
                var gc = new GraphPathComponent(current, imgPath, DetermineDirectionOfV2(previous, current, next), destVertex,edge);
                path.Add(gc);

                previous = _pathVerticies[i];
            }

            return path;
        }

        /// <summary>
        /// Generates the path and then optimizes out any successive forward motions
        /// Fore example, if verticies A B C all indicate to the user to move forward, B will be removed
        /// It will also check for duplicate images and will not display an image twice
        /// </summary>
        public List<GraphPathComponent> GenerateOptimizedPath()
        {
            var path = GeneratePath();

            var opPath = new List<GraphPathComponent>();

            if (path.Count < 2)
                return path;

            GraphPathComponent previous = null;
            GraphPathComponent current = null;
            GraphPathComponent next = null;
            for (int i = 0; i < path.Count - 1; i++)
            {
                current = path[i];
                next = path[i + 1];

                if (previous != null && current != null && next != null)
                {
                    if (previous.Direction != Direction.Forward || current.Direction != Direction.Forward ||
                        next.Direction != Direction.Forward)
                    {
                        if(opPath.Where( x => x.ImagePath == current.ImagePath).Count() == 0)
                        opPath.Add(current);
                    }
                }
                previous = path[i];
            }

            if (next != null)
                opPath.Add(next);

            return opPath;
        }
    }
}
